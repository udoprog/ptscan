// vim: ft=rust
use crate::{Type, filter::{ValueExpr, lexer::Token, ast::*}};
use num_bigint::BigInt;

grammar<'input>;

pub Or: Expression = {
    <left:And> <rest:(or And)+> => {
        let mut or = Vec::new();
        or.push(left);
        or.extend(rest.into_iter().map(|(_, r)| r));
        Expression::Or(or)
    },

    And,
}

And: Expression = {
    <left:Filter> <rest:(and Filter)+> => {
        let mut and = Vec::new();
        and.push(left);
        and.extend(rest.into_iter().map(|(_, r)| r));
        Expression::And(and)
    },

    Filter,
}

ValueExpr: ValueExpr = {
    "value" => ValueExpr::Value,
    <number:number> => ValueExpr::Number(number.0, number.1),
    <string:"string"> => ValueExpr::String(string),
};

Filter: Expression = {
    changed => Expression::Changed,
    same => Expression::Same,
    inc => Expression::Inc,
    dec => Expression::Dec,
    <expr:ValueExpr> is pointer => Expression::IsPointer(expr),
    <lhs:ValueExpr> "==" <rhs:ValueExpr> => Expression::Binary(Op::Eq, lhs, rhs),
    <lhs:ValueExpr> "!=" <rhs:ValueExpr> => Expression::Binary(Op::Neq, lhs, rhs),
    <lhs:ValueExpr> "<=" <rhs:ValueExpr> => Expression::Binary(Op::Lte, lhs, rhs),
    <lhs:ValueExpr> ">=" <rhs:ValueExpr> => Expression::Binary(Op::Gte, lhs, rhs),
    <lhs:ValueExpr> "<" <rhs:ValueExpr> => Expression::Binary(Op::Lt, lhs, rhs),
    <lhs:ValueExpr> ">" <rhs:ValueExpr> => Expression::Binary(Op::Gt, lhs, rhs),
};

extern {
    type Location = usize;
    type Error = crate::filter::lexer::Error;

    enum Token {
        "value" => Token::Value,
        changed => Token::Changed,
        same => Token::Same,
        inc => Token::Inc,
        dec => Token::Dec,
        and => Token::And,
        or => Token::Or,
        is => Token::Is,
        pointer => Token::Pointer,
        "==" => Token::Eq,
        "!=" => Token::Neq,
        "<=" => Token::Lte,
        ">=" => Token::Gte,
        "<" => Token::Lt,
        ">" => Token::Gt,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        number => Token::Literal(<BigInt>, <Option<Type>>),
        "string" => Token::String(<String>),
    }
}
