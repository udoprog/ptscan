// vim: ft=rust
use crate::{filter::{lexer::Token, ast::*}};
use num_bigint::BigInt;

grammar<'input>;

pub Or: Expression = {
    <left:And> <rest:(or And)+> => {
        let mut or = Vec::new();
        or.push(left);
        or.extend(rest.into_iter().map(|(_, r)| r));
        Expression::Or(or)
    },

    And,
}

And: Expression = {
    <left:Filter> <rest:(and Filter)+> => {
        let mut and = Vec::new();
        and.push(left);
        and.extend(rest.into_iter().map(|(_, r)| r));
        Expression::And(and)
    },

    Filter,
}

Value: Value = {
    <number:number> => Value::Number(number),
    <string:"string"> => Value::String(string),
};

Filter: Expression = {
    changed => Expression::Changed,
    same => Expression::Same,
    inc => Expression::Inc,
    dec => Expression::Dec,
    "value" "==" <value:Value> => Expression::Eq(value),
    "value" "!=" <value:Value> => Expression::Neq(value),
    "value" "<=" <value:Value> => Expression::Lte(value),
    "value" ">=" <value:Value> => Expression::Gte(value),
    "value" "<" <value:Value> => Expression::Lt(value),
    "value" ">" <value:Value> => Expression::Gt(value),
};

extern {
    type Location = usize;
    type Error = crate::filter::lexer::Error;

    enum Token {
        "value" => Token::Value,
        changed => Token::Changed,
        same => Token::Same,
        inc => Token::Inc,
        dec => Token::Dec,
        and => Token::And,
        or => Token::Or,
        "==" => Token::Eq,
        "!=" => Token::Neq,
        "<=" => Token::Lte,
        ">=" => Token::Gte,
        "<" => Token::Lt,
        ">" => Token::Gt,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        number => Token::Literal(<BigInt>),
        "string" => Token::String(<String>),
    }
}
